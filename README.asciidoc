With this command you can see the targes of the source code of jena:

----
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-war-plugin -Ddetail=true
----

Start groovysh and enter the following to grab `jena-core` from the maven
repositories:

----
@Grab('org.apache.jena:jena-core')
----


Next, follow the tutorial: https://jena.apache.org/tutorials/rdf_api.html but in
groovy.

To enter multiple lines, Groovy has to infer if each line is a complete sentence
or it is part of a multiline sentence. The following can be pasted to the
groovy shell and, each line is a complete sentence:

----

import org.apache.jena.rdf.model.*
import org.apache.jena.vocabulary.*
import org.apache.jena.util.FileManager

personURI = "http://somewhere/JohnSmith"
givenName = "John"
familyName = "Smith"
fullName = givenName + " " + familyName
model = ModelFactory.createDefaultModel()

personURI
----

The following paragraph is a multiline sentence. But we are ending each line
with an open parentheses so Groovy infers that the sentence has not ended:

----

johnSmith = model.createResource(personURI).addProperty(
VCARD.FN, fullName).addProperty(
VCARD.N,  model.createResource().addProperty(
VCARD.Given, givenName) .addProperty(
VCARD.Family, familyName))

johnSmith

----

If an error occurs on capturing a paragraph, use `:clear` clear the last buffer
on groovysh and try again. By the way, to exit groovysh use `:quit` and to get
help on the shell use `:help`. The interactive shell contains autocomplete; use
the `tab` key to autocomplete a token.


resources, literals, arcs, statements, subject, predicate, object
jonhSmith -> x
-> is an arc or _statement_. 

A statement has 3 parts:

. The subject is the resource from which the arc leaves
. The predicate is the property that labels the arc
. The object is the resource or literal pointed to by the arc

A statement is also called _triplet_.

----

model.listStatements().each{print it}

model.listStatements().each{ 
	stmt = it 
	subject = stmt.getSubject()
	predicate = stmt.getPredicate()
	object = stmt.getObject() 
	println "subject: "+subject 
	println "predicate: "+predicate
	if( object instanceof Resource) {
		println "object: "+object 
	}else{
		println "object: \""+object+"\""
	}
}

----

There are four arcs, so there are four statements.

== Writing RDF

----
model.write(System.out)
model.write(System.out, "RDF/XML-ABBREV")
model.write(System.out, "N-TRIPLES")
----

== Reading RDF

----

model = ModelFactory.createDefaultModel()
inputFileName = "vc-db-1.rdf";
infile = FileManager.get().open( inputFileName );
if(infile == null){
throw new IllegalArgumentException("File "+inputFileName+" not found")
}

model.read(infile, null)
model.write(System.out)

----


== Controlling prefixes

----

m = ModelFactory.createDefaultModel()
nsA = "http://somewhere/else#"
nsB = "http://nowhere/else#"
root = m.createResource( nsA + "root" );
P = m.createProperty( nsA + "P" )
Q = m.createProperty( nsB + "Q" )
x = m.createResource(nsA+"x")
y = m.createResource(nsA+"y")
z = m.createResource(nsA+"z")
m.add( root, P, x).add( root, P, y).add( y, Q, z)
m.write(System.out)
m.setNsPrefix("nsA", nsA)
m.write(System.out)
m.setNsPrefix( "cat", nsB )
m.write( System.out )

----

== Implicit prefix definitions

== Navigating a model

----

vcard = model.getResource("http://somewhere/JohnSmith/")
name = (Resource)vcard.getProperty(VCARD.N).getObject()
name = vcard.getProperty(VCARD.N).getResource()
name = vcard.getProperty(VCARD.N).getString() // error
fullName = vcard.getProperty(VCARD.FN).getString()

// add two nicknames to vcard

vcard.addProperty(VCARD.NICKNAME, "Smithy").addProperty(VCARD.NICKNAME, "Adman")

println("The literals of \""+ fullName +"\" are:")
iter = vcard.listProperties( VCARD.NICKNAME )
while( iter.hasNext() ) {
println(iter.nextStatement().getObject().toString() )
}

----

== Querying a model

List vcards

----

iter = model.listSubjectsWithProperty(VCARD.FN)
while(iter.hasNext()){
Resource r = iter.nextResource()
println r
}

iter = model.listSubjectsWithProperty(VCARD.FN)
if( iter.hasNext() ) {
println("The database contains vcards for:")
while(iter.hasNext()) {
println(" "+ iter.nextResource().getProperty(VCARD.FN).getString() )
}
} else {
println "No vcards were found on the database"
}

----

The same, using SimpleSelector instead listSubjectsWithProperty

----

iter = model.listStatements(
	new SimpleSelector(null, VCARD.FN, (RDFNode) null) {
		@Override public boolean selects(Statement s) {
			return s.getString().endsWith("Smith") }})

println("The database contains vcards for:")
while(iter.hasNext()) {
println(" "+ iter.nextStatement().getString() ) }

----

== Operations on models

----

inputFilename1 = "vc-db-3.rdf"
inputFilename2 = "vc-db-4.rdf"
in1 = FileManager.get().open(inputFilename1)
in2 = FileManager.get().open(inputFilename2)

model1 = ModelFactory.createDefaultModel()
model2 = ModelFactory.createDefaultModel()

model1.read(in1,"")
model2.read(in2,"")
model = model1.union(model2)

model.write(System.out, "RDF/XML-ABBREV")

----

== Containers

Create a bag

----

model = ModelFactory.createDefaultModel()
model.read(FileManager.get().open("vc-db-2.rdf"),"");

smiths = model.createBag()

iter = model.listStatements(
	new SimpleSelector(null, VCARD.FN, (RDFNode) null) {
		public boolean selects(Statement s) {
			return s.getString().endsWith("Smith")
		}
	}
)

while(iter.hasNext()){
smiths.add(iter.nextStatement().getSubject())
}

model.write(System.out)

iter2 = smiths.iterator()
if(iter2.hasNext()) {
	println("The bag contains:")
	while(iter2.hasNext()) {
		println( ((Resource) iter2.next()).getProperty(VCARD.FN).getString() ) 
	} 
} else {
	println("The bag is empty") }

----

== More about Literals and Datatypes

----
r = model.createResource()
r.addProperty(RDFS.label, model.createLiteral("chat", "en"))
r.addProperty(RDFS.label, model.createLiteral("chat", "fr"))
r.addProperty(RDFS.label, model.createLiteral("<em>chat</em>", true))
model.write(System.out)

r = model.createResource()
r.addProperty(RDFS.label, "11").addProperty(RDFS.label, 11)
model.write(System.out, "N-TRIPLE")

----

To exit groovy, enter `:quit`.





























